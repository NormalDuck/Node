"use strict";(self.webpackChunkdocs=self.webpackChunkdocs||[]).push([[792],{68354:e=>{e.exports=JSON.parse('{"functions":[{"name":"new","desc":"the constructor of the node.","params":[{"name":"x","desc":"","lua_type":"number"},{"name":"y","desc":"","lua_type":"number"},{"name":"DependentTable","desc":"","lua_type":"Board"}],"returns":[{"desc":"","lua_type":"Node"}],"function_type":"static","source":{"line":138,"path":"src/server/node.lua"}},{"name":"FindNode","desc":"find node using this node\'s coordinates","params":[{"name":"x","desc":"","lua_type":"number"},{"name":"y","desc":"","lua_type":"number"}],"returns":[{"desc":"","lua_type":"Node | nil"}],"function_type":"method","source":{"line":151,"path":"src/server/node.lua"}},{"name":"FindNeighbors","desc":"finds the the neighbors of the node (up, down, left right)","params":[],"returns":[{"desc":"","lua_type":"{ Node } | nil"}],"function_type":"method","source":{"line":166,"path":"src/server/node.lua"}},{"name":"FindSurroundings","desc":"finds the surrounding of the node.","params":[],"returns":[{"desc":"","lua_type":"{ Node } | nil"}],"function_type":"method","source":{"line":178,"path":"src/server/node.lua"}},{"name":"FindSurroundingsDeep","desc":"finds the surroundings, but you may specify how far the surrounding should be.\\n:::caution\\nthis also includes their own node when returned, this is due to my implemetation\\n:::","params":[{"name":"Depth","desc":"","lua_type":"number"}],"returns":[{"desc":"","lua_type":"{Node} | nil"}],"function_type":"method","source":{"line":193,"path":"src/server/node.lua"}},{"name":"AddData","desc":"adds a data piece of data to the node.\\n:::caution\\ncannot add data that already exists, or it will throw a error\\n:::","params":[{"name":"key","desc":"key to store data","lua_type":"string"},{"name":"value","desc":"inital data to store","lua_type":"any"}],"returns":[],"function_type":"method","source":{"line":213,"path":"src/server/node.lua"}},{"name":"OverrideData","desc":"you may use both callback or just purely overriding data.","params":[{"name":"key","desc":"key to override data","lua_type":"string"},{"name":"value","desc":"inital data to store","lua_type":"any | (oldData: any) -> any"}],"returns":[],"function_type":"method","source":{"line":224,"path":"src/server/node.lua"}},{"name":"ReconcileData","desc":"reconciles data to the node. Returns self for internal reason.","params":[{"name":"template","desc":"","lua_type":"{ [string]: any }"}],"returns":[{"desc":"","lua_type":"Node"}],"function_type":"method","source":{"line":238,"path":"src/server/node.lua"}},{"name":"HasData","desc":"returns a tuple, first param is exists and the second is the data that it has. \\n```lua\\n\\tlocal node = require(path.to.node)\\n\\tlocal thisNode = node.node.new(...)\\n\\tlocal exists, data = thisNode:HasData(\\"CustomData\\")\\n\\tprint(exists) -- false\\n\\tprint(data) -- nil\\n```","params":[{"name":"key","desc":"the key to check if the data exists or not","lua_type":"string"}],"returns":[{"desc":"","lua_type":"boolean, any"}],"function_type":"method","source":{"line":256,"path":"src/server/node.lua"}}],"properties":[],"types":[],"name":"Node","desc":"","source":{"line":119,"path":"src/server/node.lua"}}')}}]);