[{"title":"Node","type":0,"sectionRef":"#","url":"/Node/api/Node","content":"","keywords":""},{"title":"Functions​","type":1,"pageTitle":"Node","url":"/Node/api/Node#functions","content":" "},{"title":"new​","type":1,"pageTitle":"Node","url":"/Node/api/Node#new","content":"&lt;/&gt; Node.new( x: number, y: number, DependentTable: Board ) → Node the constructor of the node.  "},{"title":"FindNode​","type":1,"pageTitle":"Node","url":"/Node/api/Node#FindNode","content":"&lt;/&gt; Node:FindNode( x: number, y: number ) → Node | nil find node using this node's coordinates  "},{"title":"FindNeighbors​","type":1,"pageTitle":"Node","url":"/Node/api/Node#FindNeighbors","content":"&lt;/&gt; Node:FindNeighbors() → {Node} | nil finds the the neighbors of the node (up, down, left right)  "},{"title":"FindSurroundings​","type":1,"pageTitle":"Node","url":"/Node/api/Node#FindSurroundings","content":"&lt;/&gt; Node:FindSurroundings() → {Node} | nil finds the surrounding of the node.  "},{"title":"FindSurroundingsDeep​","type":1,"pageTitle":"Node","url":"/Node/api/Node#FindSurroundingsDeep","content":"&lt;/&gt; Node:FindSurroundingsDeep(Depth: number) → {Node} | nil finds the surroundings, but you may specify how far the surrounding should be. caution this also includes their own node when returned, this is due to my implemetation  "},{"title":"AddData​","type":1,"pageTitle":"Node","url":"/Node/api/Node#AddData","content":"&lt;/&gt; Node:AddData( key: string,-- key to store data value: any-- inital data to store ) → () adds a data piece of data to the node. caution cannot add data that already exists, or it will throw a error  "},{"title":"OverrideData​","type":1,"pageTitle":"Node","url":"/Node/api/Node#OverrideData","content":"&lt;/&gt; Node:OverrideData( key: string,-- key to override data value: any | (oldData: any) → any-- inital data to store ) → () you may use both callback or just purely overriding data.  "},{"title":"ReconcileData​","type":1,"pageTitle":"Node","url":"/Node/api/Node#ReconcileData","content":"&lt;/&gt; Node:ReconcileData(template: {[string]: any}) → Node reconciles data to the node. Returns self for internal reason.  "},{"title":"HasData​","type":1,"pageTitle":"Node","url":"/Node/api/Node#HasData","content":"&lt;/&gt; Node:HasData( key: string-- the key to check if the data exists or not ) → boolean,any returns a tuple, first param is exists and the second is the data that it has. local node = require(path.to.node) local thisNode = node.node.new(...) local exists, data = thisNode:HasData(&quot;CustomData&quot;) print(exists) -- false print(data) -- nil  "},{"title":"Board","type":0,"sectionRef":"#","url":"/Node/api/Board","content":"","keywords":""},{"title":"Functions​","type":1,"pageTitle":"Board","url":"/Node/api/Board#functions","content":" "},{"title":"new​","type":1,"pageTitle":"Board","url":"/Node/api/Board#new","content":"&lt;/&gt; Board.new( length: number, width: number, nodeTemplate: {[string]: any},-- the template for nodes to reconcile. random: Random? ) → () constructs a new board, automatically creates all the nodes using length and width. If there is nodeTemplate then automatically reconciles the node with the template. If random is specified then any random calculations will be using the random you provided  "},{"title":"FindNode​","type":1,"pageTitle":"Board","url":"/Node/api/Board#FindNode","content":"&lt;/&gt; Board:FindNode( x: number, y: number ) → Node | nil finds the node in the board, if there is any  "},{"title":"RandomNode​","type":1,"pageTitle":"Board","url":"/Node/api/Board#RandomNode","content":"&lt;/&gt; Board:RandomNode() → Node returns a random node on the board.  "},{"title":"RandomRectangle​","type":1,"pageTitle":"Board","url":"/Node/api/Board#RandomRectangle","content":"This is a yielding function. When called, it will pause the Lua thread that called the function until a result is ready to be returned, without interrupting other scripts. Yields &lt;/&gt; Board:RandomRectangle( length: number, width: number ) → {Node} finds a random rectangle caution may recursively find rectangle if the random node doesn't have a rectangle. This may lead to potential yielding or even stack overflow but the chances are depends on the board size. to prevent yielding please wrap this method with :UsePromise  "},{"title":"RandomSquare​","type":1,"pageTitle":"Board","url":"/Node/api/Board#RandomSquare","content":"This is a yielding function. When called, it will pause the Lua thread that called the function until a result is ready to be returned, without interrupting other scripts. Yields &lt;/&gt; Board:RandomSquare(size: number) → {Node}  caution may recursively find rectangle if the random node doesn't have a square. This may lead to potential yielding or even stack overflow but the chances are depends on the board size. to prevent yielding please wrap this method with :UsePromise  "},{"title":"UseFilter​","type":1,"pageTitle":"Board","url":"/Node/api/Board#UseFilter","content":"&lt;/&gt; Board:UseFilter( filterOut: {string},-- the data to see if it should exist fn: () → Node | {Node}-- the method that is going to be used ) → {Node} | nil Removes the result of the node. If the value attached to the key is false it will still be filtered out. caution when passing down the method, please create a anoymous function and return the method you're using. this applies to all Use methods  "},{"title":"UsePromise​","type":1,"pageTitle":"Board","url":"/Node/api/Board#UsePromise","content":"&lt;/&gt; Board:UsePromise( fn: () → Node | {Node}-- the method that is going to be used ) → Promise wraps the method you're using with a promise so it can avoid potential yielding. caution when passing down the method, please create a anoymous function and return the method you're using. this applies to all Use methods tip you should wrap this into any potential yielding methods. Promises are very flexible! local node = require(path.to.node) local board = node.board.new(2, 2) board :UsePromise(function() return board:RandomSquare(2) --this method may yield. end) :andThen(print)   "},{"title":"UseFilteredResult​","type":1,"pageTitle":"Board","url":"/Node/api/Board#UseFilteredResult","content":"This is a yielding function. When called, it will pause the Lua thread that called the function until a result is ready to be returned, without interrupting other scripts. Yields &lt;/&gt; Board:UseFilteredResult( filterOut: {string},-- the data to see if it should exist fn: () → Node | {Node}-- the method that is going to be used ) → () checks if any node needs to be filtered. If any node is determined to be filtered, it will call the function recursively until no node is needed to be filtered. caution when passing down the method, please create a anoymous function and return the method you're using. this applies to all Use methods local node = require(path.to.node) local board = node.board.new(2, 2) board :UsePromise(function() return board:UseFilteredResult({&quot;Visited&quot;}, function() return board:RandomSquare(2, 2) end) end) :andThen(print)  "}]